//! otpauth 9.3.1 | (c) Héctor Molinero Fernández | MIT | https://github.com/hectorm/otpauth
//! noble-hashes 1.4.0 | (c) Paul Miller | MIT | https://github.com/paulmillr/noble-hashes
/// <reference types="./otpauth.d.ts" />
// @ts-nocheck
import{hmac as e}from"@noble/hashes/hmac";import{sha1 as t}from"@noble/hashes/sha1";import{sha224 as r,sha256 as i,sha384 as s,sha512 as n}from"@noble/hashes/sha2";import{sha3_224 as o,sha3_256 as a,sha3_384 as l,sha3_512 as u}from"@noble/hashes/sha3";const h=(()=>{if("object"==typeof globalThis)return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if("undefined"!=typeof __GLOBALTHIS__)return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0})(),d={SHA1:t,SHA224:r,SHA256:i,SHA384:s,SHA512:n,"SHA3-224":o,"SHA3-256":a,"SHA3-384":l,"SHA3-512":u},c="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",f=e=>{let t=e.length;for(;"="===e[t-1];)--t;const r=(t<e.length?e.substring(0,t):e).toUpperCase(),i=new ArrayBuffer(5*r.length/8|0),s=new Uint8Array(i);let n=0,o=0,a=0;for(let e=0;e<r.length;e++){const t=c.indexOf(r[e]);if(-1===t)throw new TypeError(`Invalid character found: ${r[e]}`);o=o<<5|t,n+=5,n>=8&&(n-=8,s[a++]=o>>>n)}return s},g=e=>{let t=0,r=0,i="";for(let s=0;s<e.length;s++)for(r=r<<8|e[s],t+=8;t>=5;)i+=c[r>>>t-5&31],t-=5;return t>0&&(i+=c[r<<5-t&31]),i},p=e=>{const t=new ArrayBuffer(e.length/2),r=new Uint8Array(t);for(let t=0;t<e.length;t+=2)r[t/2]=parseInt(e.substring(t,t+2),16);return r},b=e=>{let t="";for(let r=0;r<e.length;r++){const i=e[r].toString(16);1===i.length&&(t+="0"),t+=i}return t.toUpperCase()},w=e=>{const t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=255&e.charCodeAt(t);return r},m=e=>{let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},y=h.TextEncoder?new h.TextEncoder:null,A=h.TextDecoder?new h.TextDecoder:null,I=e=>{if(!y)throw new Error("Encoding API not available");return y.encode(e)},v=e=>{if(!A)throw new Error("Encoding API not available");return A.decode(e)};class T{static fromLatin1(e){return new T({buffer:w(e).buffer})}static fromUTF8(e){return new T({
buffer:I(e).buffer})}static fromBase32(e){return new T({buffer:f(e).buffer})}static fromHex(e){return new T({buffer:p(e).buffer})}get buffer(){return this.bytes.buffer}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,writable:!1,configurable:!1,value:m(this.bytes)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,writable:!1,configurable:!1,value:v(this.bytes)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,writable:!1,configurable:!1,value:g(this.bytes)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,writable:!1,configurable:!1,value:b(this.bytes)}),this.hex}constructor({buffer:e,size:t=20}={}){this.bytes=void 0===e?(e=>{if(!h.crypto?.getRandomValues)throw new Error("Cryptography API not available");return h.crypto.getRandomValues(new Uint8Array(e))})(t):new Uint8Array(e),Object.defineProperty(this,"bytes",{enumerable:!0,writable:!1,configurable:!1,value:this.bytes})}}class ${static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}static generate({secret:t,algorithm:r=$.defaults.algorithm,digits:i=$.defaults.digits,counter:s=$.defaults.counter}){const n=((t,r,i)=>{if(e){const s=d[t.toUpperCase()];if(!s)throw new TypeError("Unknown hash function");return e(s,r,i)}throw new Error("Missing HMAC function")})(r,t.bytes,(e=>{const t=new ArrayBuffer(8),r=new Uint8Array(t);let i=e;for(let e=7;e>=0&&0!==i;e--)r[e]=255&i,i-=r[e],i/=256;return r})(s)),o=15&n[n.byteLength-1];return(((127&n[o])<<24|(255&n[o+1])<<16|(255&n[o+2])<<8|255&n[o+3])%10**i).toString().padStart(i,"0")}generate({counter:e=this.counter++}={}){return $.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate({token:e,secret:t,algorithm:r,digits:i,counter:s=$.defaults.counter,window:n=$.defaults.window}){if(e.length!==i)return null;let o=null;const a=n=>{const a=$.generate({secret:t,algorithm:r,digits:i,counter:n});((e,t)=>{{
if(e.length!==t.length)throw new TypeError("Input strings must have the same length");let r=-1,i=0;for(;++r<e.length;)i|=e.charCodeAt(r)^t.charCodeAt(r);return 0===i}})(e,a)&&(o=n-s)};a(s);for(let e=1;e<=n&&null===o&&(a(s-e),null===o)&&(a(s+e),null===o);++e);return o}validate({token:e,counter:t=this.counter,window:r}){return $.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:r})}toString(){const e=encodeURIComponent;return"otpauth://hotp/"+(this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`counter=${e(this.counter)}`}constructor({issuer:e=$.defaults.issuer,label:t=$.defaults.label,issuerInLabel:r=$.defaults.issuerInLabel,secret:i=new T,algorithm:s=$.defaults.algorithm,digits:n=$.defaults.digits,counter:o=$.defaults.counter}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret="string"==typeof i?T.fromBase32(i):i,this.algorithm=s.toUpperCase(),this.digits=n,this.counter=o}}class L{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}static generate({secret:e,algorithm:t,digits:r,period:i=L.defaults.period,timestamp:s=Date.now()}){return $.generate({secret:e,algorithm:t,digits:r,counter:Math.floor(s/1e3/i)})}generate({timestamp:e=Date.now()}={}){return L.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:t,algorithm:r,digits:i,period:s=L.defaults.period,timestamp:n=Date.now(),window:o}){return $.validate({token:e,secret:t,algorithm:r,digits:i,counter:Math.floor(n/1e3/s),window:o})}validate({token:e,timestamp:t,window:r}){return L.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:r})}toString(){const e=encodeURIComponent
;return"otpauth://totp/"+(this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`period=${e(this.period)}`}constructor({issuer:e=L.defaults.issuer,label:t=L.defaults.label,issuerInLabel:r=L.defaults.issuerInLabel,secret:i=new T,algorithm:s=L.defaults.algorithm,digits:n=L.defaults.digits,period:o=L.defaults.period}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret="string"==typeof i?T.fromBase32(i):i,this.algorithm=s.toUpperCase(),this.digits=n,this.period=o}}const S=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,U=/^[2-7A-Z]+=*$/i,E=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,H=/^[+-]?\d+$/,C=/^\+?[1-9]\d*$/;class O{static parse(e){let t;try{t=e.match(S)}catch(e){}if(!Array.isArray(t))throw new URIError("Invalid URI format");const r=t[1].toLowerCase(),i=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),s=t[3].split("&").reduce(((e,t)=>{const r=t.split(/=(.*)/,2).map(decodeURIComponent),i=r[0].toLowerCase(),s=r[1],n=e;return n[i]=s,n}),{});let n;const o={};if("hotp"===r){if(n=$,void 0===s.counter||!H.test(s.counter))throw new TypeError("Missing or invalid 'counter' parameter");o.counter=parseInt(s.counter,10)}else{if("totp"!==r)throw new TypeError("Unknown OTP type");if(n=L,void 0!==s.period){if(!C.test(s.period))throw new TypeError("Invalid 'period' parameter");o.period=parseInt(s.period,10)}}if(void 0!==s.issuer&&(o.issuer=s.issuer),2===i.length?(o.label=i[1],void 0===o.issuer||""===o.issuer?o.issuer=i[0]:""===i[0]&&(o.issuerInLabel=!1)):(o.label=i[0],void 0!==o.issuer&&""!==o.issuer&&(o.issuerInLabel=!1)),void 0===s.secret||!U.test(s.secret))throw new TypeError("Missing or invalid 'secret' parameter");if(o.secret=s.secret,void 0!==s.algorithm){if(!E.test(s.algorithm))throw new TypeError("Invalid 'algorithm' parameter")
;o.algorithm=s.algorithm}if(void 0!==s.digits){if(!C.test(s.digits))throw new TypeError("Invalid 'digits' parameter");o.digits=parseInt(s.digits,10)}return new n(o)}static stringify(e){if(e instanceof $||e instanceof L)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const _="9.3.1";export{$ as HOTP,T as Secret,L as TOTP,O as URI,_ as version};
//# sourceMappingURL=otpauth.slim.esm.min.js.map
