"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var convert = require("xml-js");
var config_1 = require("./config");
var utils_1 = require("./utils");
exports.default = (function (ins) {
    var _a;
    var options = ins.options;
    var isAtom = false;
    var base = {
        _declaration: { _attributes: { version: "1.0", encoding: "utf-8" } },
        rss: {
            _attributes: {
                version: "2.0",
                "xmlns:podcast": "https://github.com/Podcastindex-org/podcast-namespace/blob/main/docs/1.0.md",
                "xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd",
                "xmlns:dc": "http://purl.org/dc/elements/1.1/",
                "xmlns:content": "http://purl.org/rss/1.0/modules/content/",
            },
            channel: {
                title: { _text: options.title },
                lastBuildDate: { _text: options.updated ? options.updated.toUTCString() : new Date().toUTCString() },
                docs: { _text: options.docs ? options.docs : "https://validator.w3.org/feed/docs/rss2.html" },
                generator: { _text: options.generator || config_1.generator },
                "podcast:medium": { _text: options.medium || "podcast" },
            },
        },
    };
    if (options.customXMLNS) {
        Object.assign(base.rss._attributes, options.customXMLNS.reduce(function (acc, c) {
            var xmlnsName = "xmlns:".concat(c.name);
            if (xmlnsName in acc)
                return acc;
            acc[xmlnsName] = c.value;
            return acc;
        }, {}));
    }
    if (options.link) {
        base.rss.channel.link = { _text: (0, utils_1.sanitize)(options.link) };
    }
    if (options.link) {
        base.rss.channel.description = { _text: options.description };
    }
    if (options.language) {
        base.rss.channel.language = { _text: options.language };
    }
    if (options.ttl) {
        base.rss.channel.ttl = { _text: options.ttl };
    }
    if (options.guid) {
        base.rss.channel["podcast:guid"] = { _text: options.guid };
    }
    if (options.author && options.author.name) {
        if (options.author.link) {
            base.rss.channel["podcast:person"] = {
                _attributes: { href: (0, utils_1.sanitize)(options.author.link) },
                _text: options.author.name
            };
        }
        else {
            base.rss.channel["podcast:person"] = { _text: options.author.name };
        }
    }
    if (options.person) {
        var personTags = options.person.map(function (_a) {
            var role = _a.role, group = _a.group, href = _a.href, img = _a.img, name = _a.name;
            return ({
                _attributes: { role: role, group: group, href: (0, utils_1.sanitize)(href), img: (0, utils_1.sanitize)(img) },
                _text: name
            });
        });
        if (base.rss.channel["podcast:person"]) {
            personTags.unshift(base.rss.channel["podcast:person"]);
        }
        base.rss.channel["podcast:person"] = personTags;
        if (options.person.length !== 0) {
            base.rss.channel["itunes:owner"] = {
                'itunes:name': { _text: options.person[0].name },
                'itunes:email': (_a = options.locked) === null || _a === void 0 ? void 0 : _a.email
            };
        }
    }
    if (options.managingEditor && options.managingEditor.name && options.managingEditor.email) {
        base.rss.channel["managingEditor"] = { _text: "".concat(options.managingEditor.email, " (").concat(options.managingEditor.name, ")") };
    }
    if (options.webMaster && options.webMaster.name && options.webMaster.email) {
        base.rss.channel["webMaster"] = { _text: "".concat(options.webMaster.email, " (").concat(options.webMaster.name, ")") };
    }
    if (options.locked) {
        base.rss.channel["podcast:locked"] = {
            _attributes: { "owner": options.locked.email },
            _text: options.locked.isLocked ? "yes" : "no"
        };
    }
    base.rss.channel["itunes:explicit"] = { _text: options.nsfw ? "yes" : "no" };
    if (options.image) {
        base.rss.channel.image = {
            title: { _text: options.title },
            url: { _text: options.image },
            link: { _text: (0, utils_1.sanitize)(options.link) }
        };
    }
    if (options.copyright) {
        base.rss.channel.copyright = { _text: options.copyright };
    }
    ins.categories.forEach(function (category) {
        if (!base.rss.channel.category) {
            base.rss.channel.category = [];
        }
        base.rss.channel.category.push({ _text: category });
    });
    var atomLink = options.feed || (options.feedLinks && options.feedLinks.rss);
    if (atomLink) {
        isAtom = true;
        base.rss.channel["atom:link"] = [
            {
                _attributes: {
                    href: (0, utils_1.sanitize)(atomLink),
                    rel: "self",
                    type: "application/rss+xml",
                },
            },
        ];
    }
    if (options.hub) {
        isAtom = true;
        base.rss.channel["atom:link"] = {
            _attributes: {
                href: (0, utils_1.sanitize)(options.hub),
                rel: "hub"
            }
        };
    }
    if (options.stunServers) {
        base.rss.channel["podcast:stun"] = options.stunServers.map(function (stunServer) { return ({
            _text: stunServer
        }); });
    }
    if (options.trackers) {
        base.rss.channel["podcast:tracker"] = options.trackers.map(function (tracker) { return ({
            _text: tracker
        }); });
    }
    if (options.customTags) {
        addCustomTagsToObject(base.rss.channel, options.customTags);
    }
    base.rss.channel["podcast:liveItem"] = ins.podcastLiveItems.map(makePodcastLiveItemJSON);
    base.rss.channel.item = ins.podcastItems.map(makePodcastItemJSON);
    if (isAtom) {
        base.rss._attributes["xmlns:atom"] = "http://www.w3.org/2005/Atom";
    }
    return convert.js2xml(base, { compact: true, ignoreComment: true, spaces: 4 });
});
var formatCategory = function (category) {
    var name = category.name, domain = category.domain;
    return {
        _text: name,
        _attributes: {
            domain: domain,
        },
    };
};
var addCustomTagsToObject = function (o, customTags) {
    var tagsByName = customTags.reduce(function (tags, d) {
        if (d.name in tags)
            return tags;
        tags[d.name] = customTags.filter(function (g) { return g.name === d.name; });
        return tags;
    }, {});
    Object.keys(tagsByName).forEach(function (tagName) {
        if (tagName in o)
            return;
        o[tagName] = tagsByName[tagName].map(function (tag) {
            var sanitizedAttributes = {};
            if (tag.attributes) {
                sanitizedAttributes = Object.keys(tag.attributes).reduce(function (cur, key) {
                    var _a;
                    if (tag.attributes) {
                        cur[key] = (_a = (0, utils_1.sanitize)(tag.attributes[key])) !== null && _a !== void 0 ? _a : "";
                    }
                    return cur;
                }, sanitizedAttributes);
            }
            var tagObject = __assign({}, (sanitizedAttributes && { _attributes: sanitizedAttributes }));
            if (typeof tag.value === "string") {
                return __assign(__assign(__assign({}, tagObject), (tag.cdata && tag.value && { _cdata: tag.value })), (!tag.cdata && tag.value && { _text: tag.value }));
            }
            else if (tag.value) {
                addCustomTagsToObject(tagObject, tag.value);
                return tagObject;
            }
            else {
                return tagObject;
            }
        }).filter(function (tagObject) { return !!tagObject; });
    });
};
var makePodcastItemJSON = function (entry) {
    var item = {};
    if (entry.title) {
        item.title = { _cdata: entry.title };
    }
    if (entry.link) {
        item.link = { _text: (0, utils_1.sanitize)(entry.link) };
    }
    if (entry.guid) {
        item.guid = { _attributes: { isPermaLink: entry.guid.startsWith("http") }, _text: entry.guid };
    }
    else if (entry.link) {
        item.guid = { _attributes: { isPermaLink: true }, _text: (0, utils_1.sanitize)(entry.link) };
    }
    else if (entry.media[0].sources[0].uri) {
        item.guid = { _attributes: { isPermaLink: true }, _text: (0, utils_1.sanitize)(entry.media[0].sources[0].uri) };
    }
    if (entry.date) {
        item.pubDate = { _text: entry.date.toUTCString() };
    }
    if (entry.published) {
        item.pubDate = { _text: entry.published.toUTCString() };
    }
    if (entry.description) {
        item.description = { _cdata: entry.description };
    }
    if (entry.content) {
        item["content:encoded"] = { _cdata: entry.content };
    }
    if (Array.isArray(entry.author)) {
        item.author = [];
        entry.author.forEach(function (author) {
            if (author.email && author.name) {
                item.author.push({ _text: author.email + " (" + author.name + ")" });
            }
            else if (author.name) {
                item["dc:creator"] = {
                    _text: author.name
                };
            }
        });
    }
    if (entry.person) {
        item["podcast:person"] = entry.person.map(function (_a) {
            var role = _a.role, group = _a.group, href = _a.href, img = _a.img, name = _a.name;
            return ({
                _attributes: { role: role, group: group, href: (0, utils_1.sanitize)(href), img: (0, utils_1.sanitize)(img) },
                _text: name
            });
        });
    }
    if (Array.isArray(entry.category)) {
        item.category = entry.category.map(formatCategory);
    }
    if (entry.stunServers) {
        item["podcast:stun"] = entry.stunServers.map(function (stunServer) { return ({
            _text: stunServer
        }); });
    }
    if (entry.trackers) {
        item["podcast:tracker"] = entry.trackers.map(function (tracker) { return ({
            _text: tracker
        }); });
    }
    if (entry.socialInteract) {
        item["podcast:socialInteract"] = entry.socialInteract.map(function (_a) {
            var uri = _a.uri, protocol = _a.protocol, accountId = _a.accountId, accountUrl = _a.accountUrl, priority = _a.priority;
            return ({
                _attributes: { uri: (0, utils_1.sanitize)(uri), protocol: protocol, accountId: accountId, accountUrl: (0, utils_1.sanitize)(accountUrl), priority: priority }
            });
        });
    }
    if (entry.subTitle) {
        item["podcast:transcript"] = entry.subTitle.map(function (_a) {
            var url = _a.url, type = _a.type, language = _a.language, rel = _a.rel;
            return ({
                _attributes: { url: (0, utils_1.sanitize)(url), type: type, language: language, rel: rel }
            });
        });
    }
    var defaultEnclosure = entry.media[0];
    item.enclosure = {
        _attributes: {
            url: (0, utils_1.sanitize)(defaultEnclosure.sources[0].uri),
            length: defaultEnclosure.length,
            type: defaultEnclosure.type
        }
    };
    item["podcast:alternateEnclosure"] = entry.media.map(function (_a, index) {
        var type = _a.type, codecs = _a.codecs, length = _a.length, bitrate = _a.bitrate, height = _a.height, language = _a.language, rel = _a.rel, title = _a.title, sources = _a.sources, integrity = _a.integrity;
        return (__assign({ _attributes: { type: type, codecs: codecs, length: length, bitrate: bitrate, height: height, lang: language, rel: rel, title: title, default: index === 0 ? "true" : "false" }, "podcast:source": sources.map(function (_a) {
                var uri = _a.uri, contentType = _a.contentType;
                return ({ _attributes: { uri: (0, utils_1.sanitize)(uri), contentType: contentType } });
            }) }, (integrity && { "podcast:integrity": integrity === null || integrity === void 0 ? void 0 : integrity.map(function (_a) {
                var type = _a.type, value = _a.value;
                return ({ _attributes: { type: type, value: value } });
            }) })));
    });
    if (entry.thumbnails) {
        var defaultImage = entry.thumbnails[0];
        item["itunes:image"] = {
            _attributes: { href: (0, utils_1.sanitize)(defaultImage.url) }
        };
        var thumbnailsWithWidth = entry.thumbnails
            .filter(function (_a) {
            var width = _a.width;
            return width !== undefined;
        });
        if (thumbnailsWithWidth.length > 0) {
            item["podcast:images"] = {
                _attributes: {
                    srcset: thumbnailsWithWidth
                        .map(function (_a) {
                        var url = _a.url, width = _a.width;
                        return ("".concat((0, utils_1.sanitize)(url), " ").concat(width, "w"));
                    })
                        .join(", ")
                }
            };
        }
    }
    item["itunes:explicit"] = { _text: entry.nsfw ? "yes" : "no" };
    if (entry.customTags) {
        addCustomTagsToObject(item, entry.customTags);
    }
    return item;
};
var makePodcastLiveItemJSON = function (entry) {
    var item = makePodcastItemJSON(entry);
    item._attributes = __assign(__assign({ status: entry.status }, (entry.start && { start: entry.start })), (entry.end && { end: entry.end }));
    return item;
};
//# sourceMappingURL=podcast.js.map