"use strict";
// noinspection JSUnusedGlobalSymbols
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fail = exports.isUploadxError = exports.UploadxError = exports.ErrorMap = exports.ERRORS = void 0;
var ERRORS;
(function (ERRORS) {
    ERRORS["BAD_REQUEST"] = "BadRequest";
    ERRORS["FILE_CONFLICT"] = "FileConflict";
    ERRORS["FILE_ERROR"] = "FileError";
    ERRORS["FILE_NOT_ALLOWED"] = "FileNotAllowed";
    ERRORS["FILE_NOT_FOUND"] = "FileNotFound";
    ERRORS["FORBIDDEN"] = "Forbidden";
    ERRORS["GONE"] = "Gone";
    ERRORS["INVALID_CONTENT_TYPE"] = "InvalidContentType";
    ERRORS["INVALID_FILE_NAME"] = "InvalidFileName";
    ERRORS["INVALID_FILE_SIZE"] = "InvalidFileSize";
    ERRORS["INVALID_RANGE"] = "InvalidRange";
    ERRORS["METHOD_NOT_ALLOWED"] = "MethodNotAllowed";
    ERRORS["REQUEST_ENTITY_TOO_LARGE"] = "RequestEntityTooLarge";
    ERRORS["STORAGE_ERROR"] = "StorageError";
    ERRORS["TOO_MANY_REQUESTS"] = "TooManyRequests";
    ERRORS["UNKNOWN_ERROR"] = "UnknownError";
    ERRORS["UNPROCESSABLE_ENTITY"] = "UnprocessableEntity";
    ERRORS["UNSUPPORTED_MEDIA_TYPE"] = "UnsupportedMediaType";
    ERRORS["CHECKSUM_MISMATCH"] = "ChecksumMismatch";
    ERRORS["UNSUPPORTED_CHECKSUM_ALGORITHM"] = "UnsupportedChecksumAlgorithm";
    ERRORS["REQUEST_ABORTED"] = "RequestAborted";
    ERRORS["FILE_LOCKED"] = "FileLocked";
})(ERRORS || (exports.ERRORS = ERRORS = {}));
class E_ {
}
E_.errors = {};
E_._errors = {
    BadRequest: [400, 'Bad request'],
    FileConflict: [409, 'File conflict'],
    FileError: [500, 'Something went wrong writing the file'],
    FileNotAllowed: [403, 'File not allowed'],
    FileNotFound: [404, 'Not found'],
    Forbidden: [403, 'Authenticated user is not allowed access'],
    Gone: [410, 'Gone'],
    InvalidContentType: [400, 'Invalid or missing "content-type" header'],
    InvalidFileName: [400, 'Invalid file name or it cannot be retrieved'],
    InvalidFileSize: [400, 'File size cannot be retrieved'],
    InvalidRange: [400, 'Invalid or missing content-range header'],
    MethodNotAllowed: [405, 'Method not allowed'],
    RequestEntityTooLarge: [413, 'Request entity too large'],
    ChecksumMismatch: [460, 'Checksum mismatch'],
    UnsupportedChecksumAlgorithm: [400, 'Unsupported checksum algorithm'],
    StorageError: [503, 'Storage error'],
    TooManyRequests: [429, 'Too many requests'],
    UnknownError: [500, 'Something went wrong'],
    UnprocessableEntity: [422, 'Validation failed'],
    UnsupportedMediaType: [415, 'Unsupported media type'],
    RequestAborted: [499, 'Request aborted'],
    FileLocked: [423, 'File locked']
};
E_._buildErrorBody = (target, _) => {
    Object.keys(target._errors).forEach(code => {
        const [statusCode, message] = target._errors[code];
        target.errors[code] = { code, message, statusCode };
    });
};
__decorate([
    E_._buildErrorBody
], E_, "_errors", void 0);
exports.ErrorMap = E_.errors;
class UploadxError extends Error {
    constructor() {
        super(...arguments);
        this.uploadxErrorCode = ERRORS.UNKNOWN_ERROR;
    }
}
exports.UploadxError = UploadxError;
function isUploadxError(err) {
    return !!err.uploadxErrorCode;
}
exports.isUploadxError = isUploadxError;
function fail(uploadxErrorCode, detail = '') {
    return Promise.reject({
        name: 'UploadxError',
        message: uploadxErrorCode,
        uploadxErrorCode,
        detail
    });
}
exports.fail = fail;
