import { UploadxResponse } from '../types';
export declare enum ERRORS {
    BAD_REQUEST = "BadRequest",
    FILE_CONFLICT = "FileConflict",
    FILE_ERROR = "FileError",
    FILE_NOT_ALLOWED = "FileNotAllowed",
    FILE_NOT_FOUND = "FileNotFound",
    FORBIDDEN = "Forbidden",
    GONE = "Gone",
    INVALID_CONTENT_TYPE = "InvalidContentType",
    INVALID_FILE_NAME = "InvalidFileName",
    INVALID_FILE_SIZE = "InvalidFileSize",
    INVALID_RANGE = "InvalidRange",
    METHOD_NOT_ALLOWED = "MethodNotAllowed",
    REQUEST_ENTITY_TOO_LARGE = "RequestEntityTooLarge",
    STORAGE_ERROR = "StorageError",
    TOO_MANY_REQUESTS = "TooManyRequests",
    UNKNOWN_ERROR = "UnknownError",
    UNPROCESSABLE_ENTITY = "UnprocessableEntity",
    UNSUPPORTED_MEDIA_TYPE = "UnsupportedMediaType",
    CHECKSUM_MISMATCH = "ChecksumMismatch",
    UNSUPPORTED_CHECKSUM_ALGORITHM = "UnsupportedChecksumAlgorithm",
    REQUEST_ABORTED = "RequestAborted",
    FILE_LOCKED = "FileLocked"
}
export type ErrorResponses<T extends string = string> = {
    [K in T]: HttpError;
};
export declare const ErrorMap: ErrorResponses<string>;
export declare class UploadxError extends Error {
    uploadxErrorCode: ERRORS;
    detail?: unknown;
}
export declare function isUploadxError(err: unknown): err is UploadxError;
export declare function fail(uploadxErrorCode: string, detail?: unknown): Promise<never>;
export interface HttpErrorBody {
    message: string;
    code: string;
    uploadxErrorCode?: string;
    name?: string;
    retryable?: boolean;
    detail?: Record<string, any> | string;
}
export interface HttpError<T = HttpErrorBody> extends UploadxResponse<T> {
    statusCode: number;
}
