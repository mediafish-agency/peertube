"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBoolean = exports.hash = exports.memoize = exports.getLastOne = exports.getFirstOne = exports.toSeconds = exports.toMilliseconds = exports.extendObject = exports.isRecord = exports.isNumber = exports.isEqual = exports.mapValues = exports.fnv64 = exports.fnv = exports.md5 = exports.uid = exports.pick = void 0;
const crypto_1 = require("crypto");
const parse_duration_1 = require("parse-duration");
const util_1 = require("util");
const cache_1 = require("./cache");
const pick = (obj, whitelist) => {
    const result = {};
    whitelist.forEach(key => (result[key] = obj[key]));
    return result;
};
exports.pick = pick;
const uid = () => (0, crypto_1.randomBytes)(16).toString('hex');
exports.uid = uid;
function md5(str) {
    return (0, crypto_1.createHash)('md5').update(str).digest('hex');
}
exports.md5 = md5;
/**
 * FNV1A32 hash
 */
function fnv(str) {
    let hash = 2166136261;
    const bytes = Buffer.from(str, 'utf8');
    for (const byte of bytes) {
        hash ^= byte;
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return (hash >>> 0).toString(16);
}
exports.fnv = fnv;
/**
 * FNV1A64 hash
 */
function fnv64(str) {
    let hash = 14695981039346656037n;
    const offset = 1099511628211n;
    const bytes = Buffer.from(str, 'utf8');
    for (const byte of bytes) {
        hash ^= BigInt(byte);
        hash = BigInt.asUintN(64, hash * offset);
    }
    return hash.toString(16);
}
exports.fnv64 = fnv64;
function mapValues(object, func) {
    const result = {};
    const keys = Object.keys(object);
    for (const key of keys) {
        result[key] = func(object[key]);
    }
    return result;
}
exports.mapValues = mapValues;
function isEqual(a, b, ...keysToIgnore) {
    return (0, util_1.isDeepStrictEqual)(Object.entries(a).filter(e => !keysToIgnore.includes(e[0])), Object.entries(b).filter(e => !keysToIgnore.includes(e[0])));
}
exports.isEqual = isEqual;
function isNumber(x) {
    return x === Number(x);
}
exports.isNumber = isNumber;
function isRecord(x) {
    // return Object.prototype.toString.call(x) === '[object Object]';
    return x !== null && typeof x === 'object' && !Array.isArray(x);
}
exports.isRecord = isRecord;
function extendObject(target, ...sources) {
    if (!sources.length)
        return target;
    const source = sources.shift();
    if (isRecord(source)) {
        for (const key in source) {
            if (isRecord(source[key])) {
                if (!isRecord(target[key]))
                    Object.assign(target, { [key]: {} });
                extendObject(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return extendObject(target, ...sources);
}
exports.extendObject = extendObject;
/**
 * Convert a human-readable duration to ms
 */
function toMilliseconds(value) {
    if (isNumber(value))
        return value;
    if (!value)
        return undefined;
    return (0, parse_duration_1.default)(value);
}
exports.toMilliseconds = toMilliseconds;
/**
 * Convert a human-readable duration to seconds
 */
function toSeconds(value) {
    if (isNumber(value))
        return value;
    const s = (0, parse_duration_1.default)(value, 'sec');
    return s ? ~~s : s;
}
exports.toSeconds = toSeconds;
/**
 * Returns a first element of an array
 */
function getFirstOne(val) {
    return val[0];
}
exports.getFirstOne = getFirstOne;
/**
 * Returns a last element of an array
 */
function getLastOne(val) {
    return val[val.length - 1];
}
exports.getLastOne = getLastOne;
/**
 * Returns a function that caches the result of func
 * @param fn - function to be called
 */
const memoize = (fn) => {
    const cache = new cache_1.Cache(1000);
    return (arg) => {
        const key = JSON.stringify(arg);
        let result = cache.get(key);
        if (result === undefined && !cache.has(key)) {
            result = fn(arg);
            cache.set(key, result);
        }
        return result;
    };
};
exports.memoize = memoize;
exports.hash = (0, exports.memoize)(fnv64);
const toBoolean = (val) => {
    return ['true', '1', 'y', 'yes'].includes(String(val).trim().toLowerCase());
};
exports.toBoolean = toBoolean;
