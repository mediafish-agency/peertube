"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamChecksum = exports.StreamChecksum = exports.streamLength = exports.StreamLength = void 0;
const stream_1 = require("stream");
const crypto_1 = require("crypto");
class StreamLength extends stream_1.Transform {
    constructor(limit = Infinity) {
        super();
        this.limit = limit;
        this.length = 0;
    }
    _transform(chunk, encoding, cb) {
        const expected = this.length + chunk.length;
        if (this.limit >= expected) {
            this.push(chunk);
            this.length = expected;
            cb();
        }
        else {
            // this.emit('streamLengthError', new Error('Stream length limit exceeded'));
            cb(new Error('Stream length limit exceeded'));
        }
    }
}
exports.StreamLength = StreamLength;
function streamLength(limit = Infinity) {
    return new StreamLength(limit);
}
exports.streamLength = streamLength;
class StreamChecksum extends stream_1.Transform {
    constructor(checksum, algorithm, encoding = 'base64') {
        super();
        this.checksum = checksum;
        this.algorithm = algorithm;
        this.encoding = encoding;
        this.length = 0;
        this.digest = '';
        this.hash = (0, crypto_1.createHash)(algorithm);
    }
    _transform(chunk, encoding, done) {
        this.push(chunk);
        this.hash.update(chunk);
        this.length += chunk.length;
        done();
    }
    _flush(cb) {
        this.digest = this.hash.digest(this.encoding);
        if (this.checksum && this.checksum !== this.digest) {
            cb(new Error('Checksum mismatch'));
        }
        else {
            cb();
        }
    }
}
exports.StreamChecksum = StreamChecksum;
function streamChecksum(checksum = '', algorithm, encoding = 'base64') {
    return algorithm ? new StreamChecksum(checksum, algorithm, encoding) : new stream_1.PassThrough();
}
exports.streamChecksum = streamChecksum;
