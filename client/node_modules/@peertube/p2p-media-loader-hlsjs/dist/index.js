var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// lib/engine.ts
var import_events = __toESM(require_events(), 1);
import { Events as Events3, HybridLoader } from "@peertube/p2p-media-loader-core";

// lib/segment-manager.ts
var import_debug = __toESM(require_browser(), 1);
import { Events } from "@peertube/p2p-media-loader-core";

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/@videojs/vhs-utils/es/stream.js
var Stream = /* @__PURE__ */ function() {
  function Stream2() {
    this.listeners = {};
  }
  var _proto = Stream2.prototype;
  _proto.on = function on(type, listener) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(listener);
  };
  _proto.off = function off(type, listener) {
    if (!this.listeners[type]) {
      return false;
    }
    var index = this.listeners[type].indexOf(listener);
    this.listeners[type] = this.listeners[type].slice(0);
    this.listeners[type].splice(index, 1);
    return index > -1;
  };
  _proto.trigger = function trigger(type) {
    var callbacks = this.listeners[type];
    if (!callbacks) {
      return;
    }
    if (arguments.length === 2) {
      var length = callbacks.length;
      for (var i = 0; i < length; ++i) {
        callbacks[i].call(this, arguments[1]);
      }
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      var _length = callbacks.length;
      for (var _i = 0; _i < _length; ++_i) {
        callbacks[_i].apply(this, args);
      }
    }
  };
  _proto.dispose = function dispose() {
    this.listeners = {};
  };
  _proto.pipe = function pipe(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
  };
  return Stream2;
}();

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js
var import_window = __toESM(require_window());
var atob = function atob2(s) {
  return import_window.default.atob ? import_window.default.atob(s) : Buffer.from(s, "base64").toString("binary");
};
function decodeB64ToUint8Array(b64Text) {
  var decodedString = atob(b64Text);
  var array = new Uint8Array(decodedString.length);
  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }
  return array;
}

// node_modules/m3u8-parser/dist/m3u8-parser.es.js
var LineStream = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(LineStream2, _Stream);
  function LineStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.buffer = "";
    return _this;
  }
  var _proto = LineStream2.prototype;
  _proto.push = function push(data) {
    var nextNewline;
    this.buffer += data;
    nextNewline = this.buffer.indexOf("\n");
    for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
      this.trigger("data", this.buffer.substring(0, nextNewline));
      this.buffer = this.buffer.substring(nextNewline + 1);
    }
  };
  return LineStream2;
}(Stream);
var TAB = String.fromCharCode(9);
var parseByterange = function parseByterange2(byterangeString) {
  var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
  var result = {};
  if (match[1]) {
    result.length = parseInt(match[1], 10);
  }
  if (match[2]) {
    result.offset = parseInt(match[2], 10);
  }
  return result;
};
var attributeSeparator = function attributeSeparator2() {
  var key = "[^=]*";
  var value = '"[^"]*"|[^,]*';
  var keyvalue = "(?:" + key + ")=(?:" + value + ")";
  return new RegExp("(?:^|,)(" + keyvalue + ")");
};
var parseAttributes = function parseAttributes2(attributes) {
  var attrs = attributes.split(attributeSeparator());
  var result = {};
  var i = attrs.length;
  var attr;
  while (i--) {
    if (attrs[i] === "") {
      continue;
    }
    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
    attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
    result[attr[0]] = attr[1];
  }
  return result;
};
var ParseStream = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(ParseStream2, _Stream);
  function ParseStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.customParsers = [];
    _this.tagMappers = [];
    return _this;
  }
  var _proto = ParseStream2.prototype;
  _proto.push = function push(line) {
    var _this2 = this;
    var match;
    var event;
    line = line.trim();
    if (line.length === 0) {
      return;
    }
    if (line[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: line
      });
      return;
    }
    var newLines = this.tagMappers.reduce(function(acc, mapper) {
      var mappedLine = mapper(line);
      if (mappedLine === line) {
        return acc;
      }
      return acc.concat([mappedLine]);
    }, [line]);
    newLines.forEach(function(newLine) {
      for (var i = 0; i < _this2.customParsers.length; i++) {
        if (_this2.customParsers[i].call(_this2, newLine)) {
          return;
        }
      }
      if (newLine.indexOf("#EXT") !== 0) {
        _this2.trigger("data", {
          type: "comment",
          text: newLine.slice(1)
        });
        return;
      }
      newLine = newLine.replace("\r", "");
      match = /^#EXTM3U/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "inf"
        };
        if (match[1]) {
          event.duration = parseFloat(match[1]);
        }
        if (match[2]) {
          event.title = match[2];
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "targetduration"
        };
        if (match[1]) {
          event.duration = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "version"
        };
        if (match[1]) {
          event.version = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "media-sequence"
        };
        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "discontinuity-sequence"
        };
        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "playlist-type"
        };
        if (match[1]) {
          event.playlistType = match[1];
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);
      if (match) {
        event = _extends(parseByterange(match[1]), {
          type: "tag",
          tagType: "byterange"
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "allow-cache"
        };
        if (match[1]) {
          event.allowed = !/NO/.test(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "map"
        };
        if (match[1]) {
          var attributes = parseAttributes(match[1]);
          if (attributes.URI) {
            event.uri = attributes.URI;
          }
          if (attributes.BYTERANGE) {
            event.byterange = parseByterange(attributes.BYTERANGE);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "stream-inf"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          if (event.attributes.RESOLUTION) {
            var split = event.attributes.RESOLUTION.split("x");
            var resolution = {};
            if (split[0]) {
              resolution.width = parseInt(split[0], 10);
            }
            if (split[1]) {
              resolution.height = parseInt(split[1], 10);
            }
            event.attributes.RESOLUTION = resolution;
          }
          if (event.attributes.BANDWIDTH) {
            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
          }
          if (event.attributes["PROGRAM-ID"]) {
            event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "media"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-ENDLIST/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "program-date-time"
        };
        if (match[1]) {
          event.dateTimeString = match[1];
          event.dateTimeObject = new Date(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "key"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          if (event.attributes.IV) {
            if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
              event.attributes.IV = event.attributes.IV.substring(2);
            }
            event.attributes.IV = event.attributes.IV.match(/.{8}/g);
            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
            event.attributes.IV = new Uint32Array(event.attributes.IV);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-START:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "start"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-out-cont"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-out"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-in"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "skip"
        };
        event.attributes = parseAttributes(match[1]);
        if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
          event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
        }
        if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
          event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PART:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "part"
        };
        event.attributes = parseAttributes(match[1]);
        ["DURATION"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["INDEPENDENT", "GAP"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        if (event.attributes.hasOwnProperty("BYTERANGE")) {
          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "server-control"
        };
        event.attributes = parseAttributes(match[1]);
        ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "part-inf"
        };
        event.attributes = parseAttributes(match[1]);
        ["PART-TARGET"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "preload-hint"
        };
        event.attributes = parseAttributes(match[1]);
        ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
            var subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
            event.attributes.byterange = event.attributes.byterange || {};
            event.attributes.byterange[subkey] = event.attributes[key];
            delete event.attributes[key];
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "rendition-report"
        };
        event.attributes = parseAttributes(match[1]);
        ["LAST-MSN", "LAST-PART"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      _this2.trigger("data", {
        type: "tag",
        data: newLine.slice(4)
      });
    });
  };
  _proto.addParser = function addParser(_ref) {
    var _this3 = this;
    var expression = _ref.expression, customType = _ref.customType, dataParser = _ref.dataParser, segment = _ref.segment;
    if (typeof dataParser !== "function") {
      dataParser = function dataParser2(line) {
        return line;
      };
    }
    this.customParsers.push(function(line) {
      var match = expression.exec(line);
      if (match) {
        _this3.trigger("data", {
          type: "custom",
          data: dataParser(line),
          customType,
          segment
        });
        return true;
      }
    });
  };
  _proto.addTagMapper = function addTagMapper(_ref2) {
    var expression = _ref2.expression, map = _ref2.map;
    var mapFn = function mapFn2(line) {
      if (expression.test(line)) {
        return map(line);
      }
      return line;
    };
    this.tagMappers.push(mapFn);
  };
  return ParseStream2;
}(Stream);
var camelCase = function camelCase2(str) {
  return str.toLowerCase().replace(/-(\w)/g, function(a) {
    return a[1].toUpperCase();
  });
};
var camelCaseKeys = function camelCaseKeys2(attributes) {
  var result = {};
  Object.keys(attributes).forEach(function(key) {
    result[camelCase(key)] = attributes[key];
  });
  return result;
};
var setHoldBack = function setHoldBack2(manifest) {
  var serverControl = manifest.serverControl, targetDuration = manifest.targetDuration, partTargetDuration = manifest.partTargetDuration;
  if (!serverControl) {
    return;
  }
  var tag = "#EXT-X-SERVER-CONTROL";
  var hb = "holdBack";
  var phb = "partHoldBack";
  var minTargetDuration = targetDuration && targetDuration * 3;
  var minPartDuration = partTargetDuration && partTargetDuration * 2;
  if (targetDuration && !serverControl.hasOwnProperty(hb)) {
    serverControl[hb] = minTargetDuration;
    this.trigger("info", {
      message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
    });
  }
  if (minTargetDuration && serverControl[hb] < minTargetDuration) {
    this.trigger("warn", {
      message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
    });
    serverControl[hb] = minTargetDuration;
  }
  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
    serverControl[phb] = partTargetDuration * 3;
    this.trigger("info", {
      message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
    });
  }
  if (partTargetDuration && serverControl[phb] < minPartDuration) {
    this.trigger("warn", {
      message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
    });
    serverControl[phb] = minPartDuration;
  }
};
var Parser = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(Parser2, _Stream);
  function Parser2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.lineStream = new LineStream();
    _this.parseStream = new ParseStream();
    _this.lineStream.pipe(_this.parseStream);
    var self2 = _assertThisInitialized(_this);
    var uris = [];
    var currentUri = {};
    var currentMap;
    var _key;
    var hasParts = false;
    var noop = function noop2() {
    };
    var defaultMediaGroups = {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    };
    var widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    var currentTimeline = 0;
    _this.manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: []
    };
    var lastByterangeEnd = 0;
    var lastPartByterangeEnd = 0;
    _this.on("end", function() {
      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
        return;
      }
      if (!currentUri.map && currentMap) {
        currentUri.map = currentMap;
      }
      if (!currentUri.key && _key) {
        currentUri.key = _key;
      }
      if (!currentUri.timeline && typeof currentTimeline === "number") {
        currentUri.timeline = currentTimeline;
      }
      _this.manifest.preloadSegment = currentUri;
    });
    _this.parseStream.on("data", function(entry) {
      var mediaGroup;
      var rendition;
      ({
        tag: function tag() {
          ({
            version: function version2() {
              if (entry.version) {
                this.manifest.version = entry.version;
              }
            },
            "allow-cache": function allowCache() {
              this.manifest.allowCache = entry.allowed;
              if (!("allowed" in entry)) {
                this.trigger("info", {
                  message: "defaulting allowCache to YES"
                });
                this.manifest.allowCache = true;
              }
            },
            byterange: function byterange() {
              var byterange2 = {};
              if ("length" in entry) {
                currentUri.byterange = byterange2;
                byterange2.length = entry.length;
                if (!("offset" in entry)) {
                  entry.offset = lastByterangeEnd;
                }
              }
              if ("offset" in entry) {
                currentUri.byterange = byterange2;
                byterange2.offset = entry.offset;
              }
              lastByterangeEnd = byterange2.offset + byterange2.length;
            },
            endlist: function endlist() {
              this.manifest.endList = true;
            },
            inf: function inf() {
              if (!("mediaSequence" in this.manifest)) {
                this.manifest.mediaSequence = 0;
                this.trigger("info", {
                  message: "defaulting media sequence to zero"
                });
              }
              if (!("discontinuitySequence" in this.manifest)) {
                this.manifest.discontinuitySequence = 0;
                this.trigger("info", {
                  message: "defaulting discontinuity sequence to zero"
                });
              }
              if (entry.duration > 0) {
                currentUri.duration = entry.duration;
              }
              if (entry.duration === 0) {
                currentUri.duration = 0.01;
                this.trigger("info", {
                  message: "updating zero segment duration to a small value"
                });
              }
              this.manifest.segments = uris;
            },
            key: function key() {
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (entry.attributes.METHOD === "NONE") {
                _key = null;
                return;
              }
              if (!entry.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: entry.attributes
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: entry.attributes.URI
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === widevineUuid) {
                var VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                  this.trigger("warn", {
                    message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                  });
                }
                if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: entry.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: entry.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(",")[1])
                };
                return;
              }
              if (!entry.attributes.METHOD) {
                this.trigger("warn", {
                  message: "defaulting key method to AES-128"
                });
              }
              _key = {
                method: entry.attributes.METHOD || "AES-128",
                uri: entry.attributes.URI
              };
              if (typeof entry.attributes.IV !== "undefined") {
                _key.iv = entry.attributes.IV;
              }
            },
            "media-sequence": function mediaSequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + entry.number
                });
                return;
              }
              this.manifest.mediaSequence = entry.number;
            },
            "discontinuity-sequence": function discontinuitySequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + entry.number
                });
                return;
              }
              this.manifest.discontinuitySequence = entry.number;
              currentTimeline = entry.number;
            },
            "playlist-type": function playlistType() {
              if (!/VOD|EVENT/.test(entry.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + entry.playlist
                });
                return;
              }
              this.manifest.playlistType = entry.playlistType;
            },
            map: function map() {
              currentMap = {};
              if (entry.uri) {
                currentMap.uri = entry.uri;
              }
              if (entry.byterange) {
                currentMap.byterange = entry.byterange;
              }
              if (_key) {
                currentMap.key = _key;
              }
            },
            "stream-inf": function streamInf() {
              this.manifest.playlists = uris;
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              if (!currentUri.attributes) {
                currentUri.attributes = {};
              }
              _extends(currentUri.attributes, entry.attributes);
            },
            media: function media() {
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
              mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
              mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
              rendition = {
                default: /yes/i.test(entry.attributes.DEFAULT)
              };
              if (rendition.default) {
                rendition.autoselect = true;
              } else {
                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
              }
              if (entry.attributes.LANGUAGE) {
                rendition.language = entry.attributes.LANGUAGE;
              }
              if (entry.attributes.URI) {
                rendition.uri = entry.attributes.URI;
              }
              if (entry.attributes["INSTREAM-ID"]) {
                rendition.instreamId = entry.attributes["INSTREAM-ID"];
              }
              if (entry.attributes.CHARACTERISTICS) {
                rendition.characteristics = entry.attributes.CHARACTERISTICS;
              }
              if (entry.attributes.FORCED) {
                rendition.forced = /yes/i.test(entry.attributes.FORCED);
              }
              mediaGroup[entry.attributes.NAME] = rendition;
            },
            discontinuity: function discontinuity() {
              currentTimeline += 1;
              currentUri.discontinuity = true;
              this.manifest.discontinuityStarts.push(uris.length);
            },
            "program-date-time": function programDateTime() {
              if (typeof this.manifest.dateTimeString === "undefined") {
                this.manifest.dateTimeString = entry.dateTimeString;
                this.manifest.dateTimeObject = entry.dateTimeObject;
              }
              currentUri.dateTimeString = entry.dateTimeString;
              currentUri.dateTimeObject = entry.dateTimeObject;
            },
            targetduration: function targetduration() {
              if (!isFinite(entry.duration) || entry.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + entry.duration
                });
                return;
              }
              this.manifest.targetDuration = entry.duration;
              setHoldBack.call(this, this.manifest);
            },
            start: function start() {
              if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: entry.attributes["TIME-OFFSET"],
                precise: entry.attributes.PRECISE
              };
            },
            "cue-out": function cueOut() {
              currentUri.cueOut = entry.data;
            },
            "cue-out-cont": function cueOutCont() {
              currentUri.cueOutCont = entry.data;
            },
            "cue-in": function cueIn() {
              currentUri.cueIn = entry.data;
            },
            "skip": function skip() {
              this.manifest.skip = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
            },
            "part": function part() {
              var _this2 = this;
              hasParts = true;
              var segmentIndex = this.manifest.segments.length;
              var part2 = camelCaseKeys(entry.attributes);
              currentUri.parts = currentUri.parts || [];
              currentUri.parts.push(part2);
              if (part2.byterange) {
                if (!part2.byterange.hasOwnProperty("offset")) {
                  part2.byterange.offset = lastPartByterangeEnd;
                }
                lastPartByterangeEnd = part2.byterange.offset + part2.byterange.length;
              }
              var partIndex = currentUri.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ["URI", "DURATION"]);
              if (this.manifest.renditionReports) {
                this.manifest.renditionReports.forEach(function(r, i) {
                  if (!r.hasOwnProperty("lastPart")) {
                    _this2.trigger("warn", {
                      message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                    });
                  }
                });
              }
            },
            "server-control": function serverControl() {
              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
              if (!attrs.hasOwnProperty("canBlockReload")) {
                attrs.canBlockReload = false;
                this.trigger("info", {
                  message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                });
              }
              setHoldBack.call(this, this.manifest);
              if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                this.trigger("warn", {
                  message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                });
              }
            },
            "preload-hint": function preloadHint() {
              var segmentIndex = this.manifest.segments.length;
              var hint = camelCaseKeys(entry.attributes);
              var isPart = hint.type && hint.type === "PART";
              currentUri.preloadHints = currentUri.preloadHints || [];
              currentUri.preloadHints.push(hint);
              if (hint.byterange) {
                if (!hint.byterange.hasOwnProperty("offset")) {
                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                  if (isPart) {
                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                  }
                }
              }
              var index = currentUri.preloadHints.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ["TYPE", "URI"]);
              if (!hint.type) {
                return;
              }
              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                var otherHint = currentUri.preloadHints[i];
                if (!otherHint.type) {
                  continue;
                }
                if (otherHint.type === hint.type) {
                  this.trigger("warn", {
                    message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                  });
                }
              }
            },
            "rendition-report": function renditionReport() {
              var report = camelCaseKeys(entry.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [];
              this.manifest.renditionReports.push(report);
              var index = this.manifest.renditionReports.length - 1;
              var required = ["LAST-MSN", "URI"];
              if (hasParts) {
                required.push("LAST-PART");
              }
              this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
            },
            "part-inf": function partInf() {
              this.manifest.partInf = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
              if (this.manifest.partInf.partTarget) {
                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
              }
              setHoldBack.call(this, this.manifest);
            }
          }[entry.tagType] || noop).call(self2);
        },
        uri: function uri() {
          currentUri.uri = entry.uri;
          uris.push(currentUri);
          if (this.manifest.targetDuration && !("duration" in currentUri)) {
            this.trigger("warn", {
              message: "defaulting segment duration to the target duration"
            });
            currentUri.duration = this.manifest.targetDuration;
          }
          if (_key) {
            currentUri.key = _key;
          }
          currentUri.timeline = currentTimeline;
          if (currentMap) {
            currentUri.map = currentMap;
          }
          lastPartByterangeEnd = 0;
          currentUri = {};
        },
        comment: function comment() {
        },
        custom: function custom() {
          if (entry.segment) {
            currentUri.custom = currentUri.custom || {};
            currentUri.custom[entry.customType] = entry.data;
          } else {
            this.manifest.custom = this.manifest.custom || {};
            this.manifest.custom[entry.customType] = entry.data;
          }
        }
      })[entry.type].call(self2);
    });
    return _this;
  }
  var _proto = Parser2.prototype;
  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
    var missing = [];
    required.forEach(function(key) {
      if (!attributes.hasOwnProperty(key)) {
        missing.push(key);
      }
    });
    if (missing.length) {
      this.trigger("warn", {
        message: identifier + " lacks required attribute(s): " + missing.join(", ")
      });
    }
  };
  _proto.push = function push(chunk) {
    this.lineStream.push(chunk);
  };
  _proto.end = function end() {
    this.lineStream.push("\n");
    this.trigger("end");
  };
  _proto.addParser = function addParser(options) {
    this.parseStream.addParser(options);
  };
  _proto.addTagMapper = function addTagMapper(options) {
    this.parseStream.addTagMapper(options);
  };
  return Parser2;
}(Stream);

// lib/byte-range.ts
function getByteRange(context) {
  return context.rangeEnd && context.rangeStart !== void 0 ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart } : void 0;
}
function compareByteRanges(b1, b2) {
  return b1 === void 0 ? b2 === void 0 : b2 !== void 0 && b1.length === b2.length && b1.offset === b2.offset;
}
function byteRangeToString(byteRange) {
  if (byteRange === void 0) {
    return void 0;
  }
  const end = byteRange.offset + byteRange.length - 1;
  return `bytes=${byteRange.offset}-${end}`;
}

// lib/segment-manager.ts
var defaultSettings = {
  forwardSegmentCount: 20,
  swarmId: void 0,
  assetsStorage: void 0
};
var SegmentManager = class {
  constructor(loader, settings = {}) {
    this.debug = (0, import_debug.default)("p2pml:segment-manager");
    this.masterPlaylist = null;
    this.variantPlaylists = /* @__PURE__ */ new Map();
    this.segmentRequest = null;
    this.playQueue = [];
    this.onSegmentLoaded = (segment) => {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === segment.url && byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range) {
        this.segmentRequest.onSuccess(segment.data.slice(0), segment.downloadBandwidth);
        this.segmentRequest = null;
      }
    };
    this.onSegmentError = (segment, error) => {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === segment.url && byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range) {
        this.segmentRequest.onError(error);
        this.segmentRequest = null;
      }
    };
    this.onSegmentAbort = (segment) => {
      if (this.segmentRequest && this.segmentRequest.segmentUrl === segment.url && byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range) {
        this.segmentRequest.onError("Loading aborted: internal abort");
        this.segmentRequest = null;
      }
    };
    this.settings = { ...defaultSettings, ...settings };
    this.loader = loader;
    this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);
    this.loader.on(Events.SegmentError, this.onSegmentError);
    this.loader.on(Events.SegmentAbort, this.onSegmentAbort);
  }
  getSettings() {
    return this.settings;
  }
  processPlaylist(requestUrl, content, responseUrl) {
    const parser = new Parser();
    parser.push(content);
    parser.end();
    const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);
    if (playlist.manifest.playlists) {
      this.masterPlaylist = playlist;
      for (const [key, variantPlaylist] of this.variantPlaylists) {
        const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);
        if (!found) {
          this.variantPlaylists.delete(key);
        } else {
          variantPlaylist.streamSwarmId = streamSwarmId;
          variantPlaylist.streamId = "V" + index.toString();
        }
      }
    } else {
      const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);
      if (found || this.masterPlaylist === null) {
        playlist.streamSwarmId = streamSwarmId;
        playlist.streamId = this.masterPlaylist === null ? void 0 : "V" + index.toString();
        this.variantPlaylists.set(requestUrl, playlist);
        this.updateSegments();
      }
    }
  }
  async loadPlaylist(url) {
    const assetsStorage = this.settings.assetsStorage;
    let xhr;
    if (assetsStorage !== void 0) {
      let masterSwarmId;
      masterSwarmId = this.getMasterSwarmId();
      if (masterSwarmId === void 0) {
        masterSwarmId = url.split("?")[0];
      }
      const asset = await assetsStorage.getAsset(url, void 0, masterSwarmId);
      if (asset !== void 0) {
        xhr = {
          responseURL: asset.responseUri,
          response: asset.data
        };
      } else {
        xhr = await this.loadContent(url, "text");
        void assetsStorage.storeAsset({
          masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,
          masterSwarmId,
          requestUri: url,
          responseUri: xhr.responseURL,
          data: xhr.response
        });
      }
    } else {
      xhr = await this.loadContent(url, "text");
    }
    this.processPlaylist(url, xhr.response, xhr.responseURL);
    return xhr;
  }
  async loadSegment(url, byteRange) {
    const segmentLocation = this.getSegmentLocation(url, byteRange);
    const byteRangeString = byteRangeToString(byteRange);
    if (!segmentLocation) {
      let content;
      const assetsStorage = this.settings.assetsStorage;
      if (assetsStorage !== void 0) {
        let masterManifestUri = this.masterPlaylist?.requestUrl;
        let masterSwarmId;
        masterSwarmId = this.getMasterSwarmId();
        if (masterSwarmId === void 0 && this.variantPlaylists.size === 1) {
          const result = this.variantPlaylists.values().next();
          if (!result.done) {
            masterSwarmId = result.value.requestUrl.split("?")[0];
          }
        }
        if (masterManifestUri === void 0 && this.variantPlaylists.size === 1) {
          const result = this.variantPlaylists.values().next();
          if (!result.done) {
            masterManifestUri = result.value.requestUrl;
          }
        }
        if (masterSwarmId !== void 0 && masterManifestUri !== void 0) {
          const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);
          if (asset !== void 0) {
            content = asset.data;
          } else {
            const xhr = await this.loadContent(url, "arraybuffer", byteRangeString);
            content = xhr.response;
            void assetsStorage.storeAsset({
              masterManifestUri,
              masterSwarmId,
              requestUri: url,
              requestRange: byteRangeString,
              responseUri: xhr.responseURL,
              data: content
            });
          }
        }
      }
      if (content === void 0) {
        const xhr = await this.loadContent(url, "arraybuffer", byteRangeString);
        content = xhr.response;
      }
      return { content, downloadBandwidth: 0 };
    }
    const segmentSequence = (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) + segmentLocation.segmentIndex;
    if (this.playQueue.length > 0) {
      const previousSegment = this.playQueue[this.playQueue.length - 1];
      if (previousSegment.segmentSequence !== segmentSequence - 1) {
        this.playQueue = [];
      }
    }
    if (this.segmentRequest) {
      this.segmentRequest.onError("Cancel segment request: simultaneous segment requests are not supported");
    }
    const promise = new Promise(
      (resolve, reject) => {
        this.segmentRequest = new SegmentRequest(
          url,
          byteRange,
          segmentSequence,
          segmentLocation.playlist.requestUrl,
          (content, downloadBandwidth) => resolve({ content, downloadBandwidth }),
          (error) => reject(error)
        );
      }
    );
    this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence });
    void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);
    return promise;
  }
  setPlayingSegment(url, byteRange, start, duration) {
    const urlIndex = this.playQueue.findIndex(
      (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)
    );
    this.debug("Set playing segment to index %d", urlIndex, this.playQueue);
    if (urlIndex >= 0) {
      this.playQueue = this.playQueue.slice(urlIndex);
      this.playQueue[0].playPosition = { start, duration };
      this.updateSegments();
    }
  }
  setPlayingSegmentByCurrentTime(playheadPosition) {
    if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {
      return;
    }
    const currentSegmentPosition = this.playQueue[0].playPosition;
    const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;
    if (segmentEndTime - playheadPosition < 0.2) {
      this.playQueue = this.playQueue.slice(1);
      this.updateSegments();
    }
  }
  abortSegment(url, byteRange) {
    if (this.segmentRequest && this.segmentRequest.segmentUrl === url && compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)) {
      this.segmentRequest.onSuccess(void 0, 0);
      this.segmentRequest = null;
    }
  }
  abortCurrentSegment() {
    if (!this.segmentRequest) return;
    this.segmentRequest.onSuccess(void 0, 0);
    this.segmentRequest = null;
  }
  async destroy() {
    if (this.segmentRequest) {
      this.segmentRequest.onError("Loading aborted: object destroyed");
      this.segmentRequest = null;
    }
    this.masterPlaylist = null;
    this.variantPlaylists.clear();
    this.playQueue = [];
    if (this.settings.assetsStorage !== void 0) {
      await this.settings.assetsStorage.destroy();
    }
    await this.loader.destroy();
  }
  updateSegments() {
    if (!this.segmentRequest) {
      return;
    }
    const segmentLocation = this.getSegmentLocation(
      this.segmentRequest.segmentUrl,
      this.segmentRequest.segmentByteRange
    );
    this.debug("update segments", segmentLocation);
    if (segmentLocation) {
      void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);
    }
  }
  getSegmentLocation(url, byteRange) {
    for (const playlist of this.variantPlaylists.values()) {
      const segmentIndex = playlist.getSegmentIndex(url, byteRange);
      if (segmentIndex >= 0) {
        return { playlist, segmentIndex };
      }
    }
    return void 0;
  }
  async loadSegments(playlist, segmentIndex, requestFirstSegment) {
    const segments = [];
    const playlistSegments = playlist.manifest.segments;
    const initialSequence = playlist.manifest.mediaSequence ?? 0;
    let loadSegmentId = null;
    let priority = Math.max(0, this.playQueue.length - 1);
    const masterSwarmId = this.getMasterSwarmId();
    this.debug("load segments", priority, segmentIndex);
    for (let i = segmentIndex; i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount; ++i) {
      const segment = playlist.manifest.segments[i];
      const url = playlist.getSegmentAbsoluteUrl(segment.uri);
      const byteRange = segment.byterange;
      const id = this.getSegmentId(playlist, initialSequence + i);
      segments.push({
        id,
        url,
        masterSwarmId: masterSwarmId !== void 0 ? masterSwarmId : playlist.streamSwarmId,
        masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,
        streamId: playlist.streamId,
        sequence: (initialSequence + i).toString(),
        range: byteRangeToString(byteRange),
        priority: priority++
      });
      if (requestFirstSegment && !loadSegmentId) {
        loadSegmentId = id;
      }
    }
    this.loader.load(segments, playlist.streamSwarmId);
    if (loadSegmentId) {
      const segment = await this.loader.getSegment(loadSegmentId);
      if (segment) {
        this.onSegmentLoaded(segment);
      }
    }
  }
  getSegmentId(playlist, segmentSequence) {
    return `${playlist.streamSwarmId}+${segmentSequence}`;
  }
  getMasterSwarmId() {
    const settingsSwarmId = this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : void 0;
    if (settingsSwarmId !== void 0) {
      return settingsSwarmId;
    }
    return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split("?")[0] : void 0;
  }
  getStreamSwarmId(playlistUrl) {
    const masterSwarmId = this.getMasterSwarmId();
    if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {
      for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {
        const url = new URL(
          this.masterPlaylist.manifest.playlists[i].uri,
          this.masterPlaylist.responseUrl
        ).toString();
        if (url === playlistUrl) {
          return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };
        }
      }
    }
    return {
      streamSwarmId: masterSwarmId ?? playlistUrl.split("?")[0],
      found: false,
      index: -1
    };
  }
  async loadContent(url, responseType, range) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = responseType;
      if (range) {
        xhr.setRequestHeader("Range", range);
      }
      xhr.addEventListener("readystatechange", () => {
        if (xhr.readyState !== 4) return;
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(xhr);
        } else {
          reject(xhr.statusText);
        }
      });
      const xhrSetup = this.loader.getSettings().xhrSetup;
      if (xhrSetup) {
        xhrSetup(xhr, url);
      }
      xhr.send();
    });
  }
};
var Playlist = class {
  constructor(requestUrl, responseUrl, manifest) {
    this.requestUrl = requestUrl;
    this.responseUrl = responseUrl;
    this.manifest = manifest;
    this.streamSwarmId = "";
  }
  getSegmentIndex(url, byteRange) {
    for (let i = 0; i < this.manifest.segments.length; ++i) {
      const segment = this.manifest.segments[i];
      const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);
      if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {
        return i;
      }
    }
    return -1;
  }
  getSegmentAbsoluteUrl(segmentUrl) {
    return new URL(segmentUrl, this.responseUrl).toString();
  }
};
var SegmentRequest = class {
  constructor(segmentUrl, segmentByteRange, segmentSequence, playlistRequestUrl, onSuccess, onError) {
    this.segmentUrl = segmentUrl;
    this.segmentByteRange = segmentByteRange;
    this.segmentSequence = segmentSequence;
    this.playlistRequestUrl = playlistRequestUrl;
    this.onSuccess = onSuccess;
    this.onError = onError;
  }
};

// lib/hlsjs-loader.ts
var import_debug2 = __toESM(require_browser(), 1);
import { Events as Events2 } from "@peertube/p2p-media-loader-core";
var HlsJsLoader = class _HlsJsLoader {
  constructor(segmentManager) {
    this.segmentManager = segmentManager;
    this.debug = (0, import_debug2.default)("p2pml:hlsjs-loader");
    this.stats = {
      loaded: 0,
      total: 0,
      aborted: false,
      retry: 0,
      chunkCount: 0,
      bwEstimate: 0,
      loading: {
        start: 0,
        end: 0,
        first: 0
      },
      parsing: {
        start: 0,
        end: 0
      },
      buffering: {
        start: 0,
        end: 0,
        first: 0
      }
    };
    this.boundOnSegmentAbort = this.onSegmentAbort.bind(this);
    this.boundOnUpdateSegmentSize = this.onUpdateSegmentSize.bind(this);
    this.boundOnUpdateLoaded = this.onUpdateLoaded.bind(this);
    this.boundOnSegmentStartLoad = this.onSegmentStartLoad.bind(this);
    this.debugId = "";
  }
  async load(context, _config, callbacks) {
    this.context = context;
    this.callbacks = callbacks;
    _HlsJsLoader.updateStatsToStartLoading(this.stats);
    if (this.context.type) {
      this.debug(`Loading playlist ${this.context.url}.`);
      try {
        const result = await this.segmentManager.loadPlaylist(this.context.url);
        this.debug(`Playlist ${this.context.url} loaded.`);
        this.successPlaylist(result, this.context, this.callbacks);
      } catch (e) {
        this.error(e, this.context, this.callbacks);
      }
    } else if (this.context.frag) {
      this.loader = this.segmentManager.loader;
      this.byteRange = getByteRange(this.context);
      this.debugId = this.byteRange ? `${this.context.url} / ${this.byteRange.offset}` : this.context.url;
      this.debug(`Loading fragment ${this.debugId}.`);
      this.interval = setInterval(() => _HlsJsLoader.updateStatsToStartLoading(this.stats), 200);
      this.loader.on(Events2.SegmentAbort, this.boundOnSegmentAbort);
      this.loader.on(Events2.SegmentSize, this.boundOnUpdateSegmentSize);
      this.loader.on(Events2.SegmentStartLoad, this.boundOnSegmentStartLoad);
      try {
        const result = await this.segmentManager.loadSegment(this.context.url, this.byteRange);
        const { content } = result;
        if (content) {
          this.successSegment(content, this.context, this.callbacks);
          this.debug(`Loaded fragment ${this.debugId}.`);
        } else {
          this.cleanup();
          this.debug(`Loaded empty fragment ${this.debugId} (aborted?).`);
        }
      } catch (e) {
        setTimeout(() => this.error(e, this.context, this.callbacks), 0);
        this.debug(`Error in fragment ${this.debugId} loading.`, e);
      }
    } else {
      console.warn("Unknown load request", this.context);
    }
  }
  abort(context, callbacks) {
    if (this.stats.loading.end || this.stats.aborted) return;
    this.debug(`Aborting by hls.js fragment ${this.debugId} loading.`);
    this.cleanup();
    this.segmentManager.abortSegment(context.url, getByteRange(context));
    this.stats.aborted = true;
    const onAbort = callbacks?.onAbort;
    if (onAbort) {
      onAbort(this.stats, context, void 0);
    }
  }
  successPlaylist(xhr, context, callbacks) {
    this.cleanup();
    const now = performance.now();
    this.stats.loading.end = now;
    this.stats.loaded = xhr.response.length;
    this.stats.total = xhr.response.length;
    callbacks.onSuccess(
      {
        url: xhr.responseURL,
        data: xhr.response
      },
      this.stats,
      context,
      void 0
    );
  }
  successSegment(content, context, callbacks) {
    this.cleanup();
    const now = performance.now();
    this.stats.loading.end = now;
    this.stats.loaded = content.byteLength;
    this.stats.total = content.byteLength;
    if (callbacks.onProgress) {
      callbacks.onProgress(this.stats, context, content, void 0);
    }
    callbacks.onSuccess(
      {
        url: context.url,
        data: content
      },
      this.stats,
      context,
      void 0
    );
  }
  error(error, context, callbacks) {
    this.cleanup();
    callbacks.onError(error, context, void 0, this.stats);
  }
  cleanup() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = void 0;
    }
    if (this.loader) {
      this.loader.off(Events2.SegmentStartLoad, this.boundOnSegmentStartLoad);
      this.loader.off(Events2.SegmentSize, this.boundOnUpdateSegmentSize);
      this.loader.off(Events2.PieceBytesDownloaded, this.boundOnUpdateLoaded);
      this.loader.off(Events2.SegmentAbort, this.boundOnSegmentAbort);
    }
  }
  onSegmentAbort(segment) {
    if (!this.isSegment(segment)) return;
    this.debug(`Aborting by p2p-media-loader fragment ${this.debugId || ""}.`);
    this.stats.aborted = true;
    const onAbort = this.callbacks?.onAbort;
    if (onAbort) {
      onAbort(this.stats, this.context, void 0);
    }
    this.cleanup();
  }
  onUpdateSegmentSize(segment, size) {
    if (!this.isSegment(segment)) return;
    this.stats.total = size;
  }
  onUpdateLoaded(_type, segment, bytes) {
    if (!this.isSegment(segment)) return;
    this.stats.loaded += bytes;
  }
  onSegmentStartLoad(method, segment) {
    if (!this.interval || method !== "http" || !this.isSegment(segment)) return;
    clearInterval(this.interval);
    this.interval = void 0;
    _HlsJsLoader.updateStatsToStartLoading(this.stats);
    this.loader.on(Events2.PieceBytesDownloaded, this.boundOnUpdateLoaded);
  }
  isSegment(segment) {
    return segment.url === this.context.url && segment.range === byteRangeToString(this.byteRange);
  }
  static updateStatsToStartLoading(stats) {
    if (stats.aborted) return;
    const start = performance.now();
    stats.loading.start = start;
    stats.loading.first = start;
  }
};

// lib/engine.ts
var Engine = class extends import_events.EventEmitter {
  constructor(settings = {}) {
    super();
    this.currentLoaders = [];
    this.loader = new HybridLoader(settings.loader);
    this.segmentManager = new SegmentManager(this.loader, settings.segments);
    Object.keys(Events3).map((eventKey) => Events3[eventKey]).forEach((event) => this.loader.on(event, (...args) => this.emit(event, ...args)));
  }
  static isSupported() {
    return HybridLoader.isSupported();
  }
  createLoaderClass() {
    this.abortCurrentRequest();
    const engine = this;
    const loader = class {
      constructor() {
        this.load = async (context, config, callbacks) => {
          if (context.url.endsWith(".m3u8") !== true) {
            engine.addLoaderImpl(this);
          }
          this.context = context;
          this.callbacks = callbacks;
          await this.impl.load(context, config, callbacks);
        };
        this.abort = () => {
          if (this.context) {
            this.impl.abort(this.context, this.callbacks);
          }
        };
        this.destroy = () => {
          if (this.context) {
            this.impl.abort(this.context);
          }
          engine.removeLoaderImpl(this);
        };
        this.getResponseHeader = () => void 0;
        this.impl = new HlsJsLoader(engine.segmentManager);
        this.stats = this.impl.stats;
      }
      static {
        this.getEngine = () => {
          return engine;
        };
      }
    };
    return loader;
  }
  async destroy() {
    this.currentLoaders = [];
    await this.segmentManager.destroy();
  }
  abortCurrentRequest() {
    for (const loader of this.currentLoaders) {
      loader.abort();
    }
    this.currentLoaders = [];
  }
  getSettings() {
    return {
      segments: this.segmentManager.getSettings(),
      loader: this.loader.getSettings()
    };
  }
  getDetails() {
    return {
      loader: this.loader.getDetails()
    };
  }
  setPlayingSegment(url, byteRange, start, duration) {
    this.segmentManager.setPlayingSegment(url, byteRange, start, duration);
  }
  setPlayingSegmentByCurrentTime(playheadPosition) {
    this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);
  }
  addLoaderImpl(loader) {
    this.currentLoaders.push(loader);
  }
  removeLoaderImpl(loader) {
    this.currentLoaders = this.currentLoaders.filter((l) => l !== loader);
  }
};

// lib/index.ts
var import_debug3 = __toESM(require_browser(), 1);
var version = "0.6.2";
var debug = (0, import_debug3.default)("p2pml:hlsjs-init");
function initHlsJsPlayer(videojsPlayer, hlsjs) {
  if (hlsjs && hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === "function") {
    initHlsJsEvents(videojsPlayer, hlsjs, hlsjs.config.loader.getEngine());
  }
}
function initHlsJsEvents(player, hlsjs, engine) {
  const onSeek = function() {
    debug("Player seeking.");
    engine.abortCurrentRequest();
  };
  player.on("seeking", onSeek);
  hlsjs.on("hlsFragChanged", (_event, data) => {
    debug("HLS Frag changed.", data);
    const frag = data.frag;
    const byteRange = frag.byteRange.length !== 2 ? void 0 : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };
    engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);
  });
  hlsjs.on("hlsError", (_event, errorData) => {
    if (errorData.details === "bufferStalledError") {
      const htmlMediaElement = player.media === void 0 ? player.el_ : player.media;
      if (htmlMediaElement) {
        engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);
      }
    }
  });
  hlsjs.on("hlsDestroying", async () => {
    try {
      await engine.destroy();
      player.off("seeking", onSeek);
    } catch (err) {
      console.error(err);
    }
  });
}
export {
  Engine,
  SegmentManager,
  initHlsJsPlayer,
  version
};
/**
 * @license Apache-2.0
 * Copyright 2018 Novage LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*! Bundled license information:

m3u8-parser/dist/m3u8-parser.es.js:
  (*! @name m3u8-parser @version 4.7.1 @license Apache-2.0 *)
*/
