export declare enum ErrorType {
    NotFound = 0,
    Auth = 1,
    Retryable = 2,
    Fatal = 3
}
export declare type ShouldRetryFunction = (code: number, attempts: number) => boolean;
export declare type KeepPartialFunction = (code: number) => boolean;
export interface RetryConfig {
    /** Maximum number of retry attempts */
    maxAttempts?: number;
    /** Upload not exist status codes */
    shouldRestartCodes?: number[];
    /** Bad token? status codes */
    authErrorCodes?: number[];
    /** Retryable 4xx status codes */
    shouldRetryCodes?: number[];
    /** Overrides the built-in function that determines whether the operation should be repeated */
    shouldRetry?: ShouldRetryFunction;
    /** The minimum retry delay */
    minDelay?: number;
    /** The maximum retry delay */
    maxDelay?: number;
    /** Delay used between retries for non-error responses with missing range/offset */
    onBusyDelay?: number;
    /** Time interval after which hanged requests must be retried */
    timeout?: number;
    /** Determines whether partial chunks should be kept */
    keepPartial?: boolean | KeepPartialFunction;
}
/**
 * Retryable ErrorHandler
 */
export declare class RetryHandler {
    attempts: number;
    config: Required<RetryConfig>;
    private observedValue?;
    cancel: () => void;
    constructor(configOptions?: RetryConfig);
    /**
     * Determine error type based on response code
     * @param code - HTTP response status code
     */
    kind(code: number): ErrorType;
    /**
     * Wait before next retry attempt
     * @param time - Delay in ms
     */
    wait(time?: number): Promise<void>;
    /**
     * Observes value to reset retry attempts counter
     * @param value - Value to observe
     */
    observe(value?: string | number): void;
}
